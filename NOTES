
TODO

  * Client & Connection with TONS OF TESTING.
    - Error & Message Handling
      * Test inserting invalid xml in xml data type, timed our for me.
      * Misc code to implement in error handler maybe?
        // - Abort the program, or
        // - Return an error code and mark the DBPROCESS as “dead” (making it unusable), or
        // - Cancel the operation that caused the error, or
        // - Keep trying (in the case of a timeout error).
        // if ((dbproc == NULL) || (dbdead(dbproc)))
        //   return INT_EXIT;
        // if (oserr != DBNOERR) {
        //   return INT_CANCEL;
        // }
      • Look Into: dbdead
      • If you have installed a server message handler, you may want to write your DB-Library error handler so 
        as to suppress the printing of any SYBESMSG error, to avoid notifying the user about the same error twice.

  * Result Set with TONS OF TESTING.
    - Error & Message Handling
      • Look Into Timeouts
        - dbsettime - Set the number of seconds that DB-Library will wait for a server response to a SQL 
          command. (int seconds) Set a connect_timeout= method like Mysql2 gem, hook into initial connect too.
      • TSQL 'print' and 'raiserror' commands generate server messages that dbmsghandle will catch. (test)
      • See the dbsetuserdata reference page for an example of how to handle deadlock in this way.
    - Looking into use dbfreebuf when the result is built as a way of preemptively clearing the command buffer. 
      Maybe use DBNOAUTOFREE with this.
    - Test large data set in wchars
    - See if wchar max is only supported in newer FreeTDS
  
  * Make an escape method. Like Mysql2 gem.



FreeTDS Notes

  * Compile Flags
    --disable-debug (test speed improvement)
      http://www.freetds.org/userguide/logging.htm
      http://www.freetds.org/userguide/seemtooslow.htm
  * Is it possible to over ride the "tds version" in the conf file? If not what does dbsetlversion do?
  * Right now we have no interrupt handler to cancel a bad SELECT * or long SQL. Maybe use dbsetinterrupt




--------------
Encoding Notes
--------------

  * Testing
    - All metadata (table names and such) are encoded according to UCS-2 on the wire. (test non-ascii col names)
    - Unicode in conditions string
    - Unicode in inserts
  
  * Misc Website
    - http://blog.grayproductions.net/categories/character_encodings
    - http://tenderlovemaking.com/2009/06/26/string-encoding-in-ruby-1-9-c-extensions/
    - http://www.freetds.org/userguide/localization.htm
    - http://www.freetds.org/userguide/aboutunicode.htm
    
  * Ruby 1.9 & Rails Info
    - Objects: #<Encoding:UTF-16BE>, #<Encoding:Windows-1251>, #<Encoding:UTF-16LE>
               #<Encoding:ASCII-8BIT>, #<Encoding:US-ASCII>,
    - Aliases: "UCS-2BE"=>"UTF-16BE", "CP1251"=>"Windows-1251"
               "BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII"
    - Might need to make a map of common database.yml possibilities
      Any valid iconv character set (iconv -l)
  * FreeTDS Info
    - The 7.0 TDS version transfers all character data in UCS-2 (Unicode, 2bytes/character)
    - Look Into: DBSETLCHARSET, dbcharsetconv, dbservcharset, dbgetcharset
    - FreeTDS is not fully compatible with multi-byte character sets such as UCS-2. 
      You must use an ASCII-extension charset (e.g., UTF-8, ISO-8859-*)[2]
    - FreeTDS determines the server's encoding from the TDS protocol and information 
      reported by the server (generally per connection, but in the case of TDS 8.0, 
      per result set column)

  * Notes From FreeTDS Mailing List
    ----------------------------------------------------------------------------------------------------------
    = Attempt was map (char,varchar) to TStringField and (nchar,nvarchar) to TWideStringField.
    ----------------------------------------------------------------------------------------------------------
    Unfortunately it will be quite difficult with db-lib, because FreeTDS intentionally conceals the server
    column definition. It was a design decision (maybe not the right one!) but it's very deep in the library.  
    As soon as UCS-2 data arrive from the server, they are immediately converted to the client's encoding.
    The UCS-2 form is discarded.[1] To provide UCS-2 data to FreePascall, you'll have to re-convert! Getting 
    db-lib to report the server's type and size wouldn't be particularly hard. The TDSCOLUMN structure has a 
    nested on_server structure with exactly that information. That structure could be harmlessly added to the 
    DBCOL structure filled by dbcolinfo(). I think if you look at dbcolinfo() and dbcoltype(), you'll see what 
    to do. Look at tds_set_column_type() too. --jkl
    [1] This was my design many years ago, and I now think it was the wrong choice. Converting 
    to the client's charset is a matter of *binding*, and binding should be handled as late as 
    possible. dbbind() is where the conversion should happen, and dbdata() should return the 
    original UCS-2 data as delivered by the server.
    ----------------------------------------------------------------------------------------------------------
    = FreeTDS and SQL Server 2008 UTF-16 characters
    ----------------------------------------------------------------------------------------------------------
    From all that I learned about this, it seems it would be safe intepreting the UCS-2 characters as UTF-16
    ... I would appreciate your help with such a change... for sure I can help with testing it.
    >> 
    I have a suggestion for a hack. If you're right and I'm right, it might work. In src/tds/iconv.c, the 
    string constant "UCS-2LE" appears 4 times. Change them to "UTF-16LE".  Recompile.  Make sure you're using 
    GNU libiconv. Run your test. Watch for smoke. If UTF-16 really is a superset of UCS-2, it should Just Work. 
    That change doesn't fake anything; it just treats as UTF-16 what would otherwise be regarded as UCS-2. 
    If it works, please update the comments and the variable names (and for extra credit, the documentation), 
    post your patch and call it a day. --jkl
    >> 
    So far I can say it is working very well! Unicode characters outside the BMP are now correctly converted to 
    UTF-16 and back to UTF-8. The characters in the UCS-2 range still seem to work too.
    >> 
    The big problem about moving from ucs2 to utf16 is portability. There are some implementations (like HP-UX one) 
    which sticks to ucs2 internal format and BMP 0. In these implementations conversions to/from ucs2 are available
    without problems while conversions to/from utf16 are not. We don't handle utf16 in our replacements library but 
    is not that hard to add it (I already wrote the patch). --jkl


